\begin{kasten}
    \section*{ \hspace{0.1cm} {\color{red} \underline{SUMMARY}}}
    \Large{

\hspace{6mm}This paper explores classifiction with disjunctive sets using a modified form of HyperPipes [1] called MultiPipes. Rather than apply HyperPipes it's intended sparse datasets, we find that it's application to non-sparse, many-class datasets typically results in several tied classification scores which we then union into a disjunction. This union presents interesting possibilities in it's high accuracy in containing the target class. Although we initially cannot predict single classes, we find that these disjunctions often eliminate large portions of possible classes. Essentialy we aren't certain what the class is, but we are very certain of what the class is not. The rest of the paper explores two alternative strategies with MultiPipes. The first involves methods of reducing the disjunctive sets to single classifications. The second considers growing the disjunctive sets to optimize the accuracy of containment vs. set size.
    }
\end{kasten}

\begin{kasten}
  \section*{ \hspace{0.1cm} {\color{red} \underline{HyperPipes}}}
\large{
HyperPipes is a learner originally designed by Witten [3] and implemented by Eisenstein et al [1] for extremely large, sparse datasets. Rather than maintain a large working memory of statistics on each row of data, HyperPipes maintains a small data structure for each class that merely "remembers" whether a particular attribute has been encountered before. For numerics, a range of maximum and minimum values encountered is kept. When classifying, original HyperPipes classifies a row based on which class most "contains" the current attributes. For numeric attributes, a new instance is "contained" if it falls within the maximum and minimum values see so far.
\vspace{3 mm}
%\begin{program}
%\footnotesize
\begin{algorithmic}
\Procedure {RunHyperPipes}{$Nothing$}
\State $HyperPipes := array[]$
\State $Guessed := 0$
\State $GuessedCorrect := 0$
\ForAll {Line in DataFile}
\State $Guessed++$
\State $GuessedCorrect \mbox{+=} Classify(MyHyperPipes,Line)$
\State $HyperPipes := AddExperience(Line,HyperPipes)$
\EndFor
\State $Accuracy := GuessedCorrect/Guessed$
\EndProcedure
\end{algorithmic}
%\end{program}
}
\end{kasten}

\begin{kasten}
    \section*{ \hspace{0.1cm} {\color{red} \underline{PRIORITIZATION POLICIES}}}
    \large{
A prioritization policy determines how many requirements are initially known and
how the plan is modified when new requirements arrive.

\vspace{3 mm}
POM 2 explores two prioritization policies:
\begin{smallenum}
\item Plan Based (PB) : A non-agile development method
  where requirements are sorted once at the start of development
  using the original \(\frac{value}{cost}\) numbers assumed at the start 
  of the project.
\item Agile2 (AG2) : A development method where requirements are sorted every iteration on  policies sort requirements (every iteration) on \(\frac{value}{cost}\). 
\end{smallenum}
\vspace{-0.2em}
}
\end{kasten}
