#summary Notes on Ourmine's LISP code.


<wiki:toc max_depth="4" />  

= The Big Picture =

== Development Structure ==

This code was written using a test-driven approach; i.e. whenever I built a new functionality, I wrote a _deftest_ command to test that code. 

{{{
(deftest test-normal ()
  (let ((n (make-normal)))
    (dolist (x '( 1 2 3 4 5 4 3 2 1))
      (add n x))
    (check 
      (samep n "#S(NORMAL :MAX 5 :MIN 1 :N 9 :SUM 25 :SUMSQ 85)")
      (equal (mean n) (/ 25 9))
      (equal (stdev n) 1.3944334)
      (samep (format nil "~10,9f" (pdf n 5))  ".080357649")
    )))
}}}
This code throws a set of numbers at a normal distribution. If it is working correctly, then that distribution should generate certain values.

The above shows four _check_s. The _samep_ functions checks if two forms evaluate to the same print string, ignoring minor details like white space and capitalization.

A site effect of using _deftest_ is that a global _*tests*_ stores all the known tests and the _(tests)_ function can report what percent of the test suite is working right now.

It is impossible to understate the value of this kind of development. Everyday, I stop with a broken test. Every new day, I start with the test broken from last night. And if ever I make any changes to anything, I can check if that breaks anything else.

== Code structure ==

At the time of this writing, the main LISP directory is our/lib/lisp. This is broken down into:

 * [#miner.lisp our/lib/lisp/miner.lisp] : main load file. Loads the rest of the code.
 * [#tests our/lib/lisp/tests] : code for test suite
 * [#tricks our/lib/lisp/tricks] : general LISP utils
 * [#table our/lib/lisp/table] : code for storing data 
 * [#learn our/lib/lisp/learn] : code for learners 

This code structure will be discussed below.

== Getting Started ==

First, you have to [http://ourmine.googlecode.com install Ourmine]. Then
at the UNIX shell prompt:
{{{
cd ~/opt/our/lib/lisp
emacs
}}}
Once inside EMACS:
{{{
M-x slime
(load "miner.lisp")
}}}

== Data Structure ==

=== Main Data Structures ===

At the time of this writing, the main data structures are:

 * *eg* : an example data row
 * *header* : meta-information about each column of data (e.g. the maximum and minimum number seen in an row in a particular column). Headers have two sub-classes
   * *Discrete* : for non-numeric data
   * *Numeric*  : for numeric data
 * *table* : combines examples with column headers. 
 

For example, this code returns a _table_ with five _eg_s, one for each row of the data:

{{{
(defun did-you-play-golf ()
  (data
    :name   'weather
    :columns '( forecast temp humidity $wind play)
    :egs     '((sunny    hot  high     20    no) 
               (sunny    hot  high     10    no) 
               (sunny    hot  high     30    no) 
               (sunny    hot  high     20.2  yes)
               (sunny    hot  high     20.1  yes)
               (sunny    hot  high     20.7  yes)
              )
)
}}}

The table has four _discrete_ columns (forecast, temp, humidity, play) and one numeric one (denoted with a "$" sign: see"$wind"). The last column is the _class_ (so it  columns satisfies _header-classp_).  

Optionally, the columns can store frequency counts of the data seen in each column.  The code

{{{
(xindex (did-you-play-golf))
}}}
runs over the table and:
 * For _discrete_ columns, it stores the count of symbols seen in each class.
 * _Numeric_ columns are summarized,  assuming  [http://en.wikipedia.org/wiki/Normal_distribution normal distributions].


=== Other Structures ==

 * *normal* : used to store normal distributions and report mean, standard deviation, pdf, etc.
 * *caution* : collects any error strings on flaws found  when reading the data. If two many flaws are found, _caution_ calls an abort.

= The Details = 

== miner.lisp ==

This file defines a list of files to load; e.g. 
{{{
(defparamater *files* '(
                          "tests/deftest"
                          "tricks/lispfuns"
                          etc
                       ))
}}}
Once this file is loaded, then the whole system can be reloaded with _make_. 
{{{
(defun make (&optional (verbose nil))
  (if verbose
      (make1 *files*)
      (handler-bind 
          ((style-warning #'muffle-warning))
        (make1 *files*))))
}}}
_make_ works in two modes. The call _(make)_ loads the system, suppressing SBCL's verbose load information. To see that output, use _(make t)_.

Note that there is a better way to define systems in LISP- the asdf system. But while debugging this code, I found some quirks in my local
installation of that system, so....

== tests ==

 <em>Debugging had to be discovered.  I can remember the exact instant
when I realized that a large part of my life from then on was going
to be spent in finding mistakes in my own programs. </em>
<br>--Maurice Wilkes, 1949



At least half the development time of any system is spent debugging the code. So it is worthwhile to spend a little time
simplifying this very, very, common task.

The unit test system used by Ourmine is based on code  from Peter Seibel. The _deftest_ macro calls a _defun_ and, as a side-effect, registers
the test in a list *tests*. One test can can contain _check_s and, if passed, each _check_ adds one to a counter of passed tests:
{{{
(deftest test-normal ()
  (let ((n (make-normal)))
    (dolist (x '( 1 2 3 4 5 4 3 2 1))
      (add n x))
    (check 
      (samep n "#S(NORMAL :MAX 5 :MIN 1 :N 9 :SUM 25 :SUMSQ 85)")
      (equal (mean n) (/ 25 9))
      (equal (stdev n) 1.3944334)
      (samep (format nil "~10,9f" (pdf n 5))  ".080357649")
    )))
}}}
An individual test like _test-normal_ can be 
called like any other function.

All the current tests can be called using _(tests)_. 
When _(tests)_ terminates, it reports what percent of tests passed/failed.


== tricks ==

Tricks stores some common COMMON LISP tricks- should be useful for more than just Ourmine.

=== list.lisp ===
<dl>
<dt>_(shuffle list)_ </dt>
<dd>Returns a randomly reordered _list_. Note: the original _list_ is changed by this function.</dd>
</dl>
=== string.lisp ===
<dl>
<dt>_(lt x y)_ </dt><dd>
Returns true if _x_ is lexogragphically less than _y_.
</dd>
<dt>_(nchars integer &optional char)_ </dt><dd>
Returns a string of length _integer_ containin _char_ (default: space).
</dd>
<dt>_(samep x y)_ </dt><dd>
Returns true if a  string comparison of the results _x_ and ithe results of _y_
are lexiographically different. Ignores differences like whitespace of upper or lower case.
</dd>
<dt>_(whiteout seq)_ </dt><dd>
Returns a sequence without any whitespace (space, tab, newline, page breaks).
</dd>
</dl>

=== hash.lisp ===
<dl>
<dt>_(print-object hash stream)_ </dt><dd>
Redefines the printed representation of a hashtable. 
</dd>
<dt>_(showh hash &key indent stream before after if-empty show lt)_ </dt><dd>
Pretty prints the contents of _hash_ on _stream_ (defaults to standard ouput). 
The strings _before_ and _after_ are printed before and after showing the hash table contents.
Buckets are printed in a sort order controlled by _lt_. If a bucket is empty, _if-empty_ is shown.

In this example, fruit is stored in a hash table at a key equal to the string length of the fruit (e.g. "PEAR" goes to "4"):
{{{
(deftest test-showh ()
  (let ((h (make-hash-table)))
    (dolist (one '(apple pear banana))
      (setf (gethash (length (string one)) h) one))
   (check
     (samep (with-output-to-string (s) 
            (showh h  :stream s))
                "4 = PEAR
                 5 = APPLE
                 6 = BANANA"
))))
}}}
</dd>
</dl>
=== macros.lisp ===
==== Macros for Debugging =====

<dl>
<dt>_(o &rest items)_</dt><dd>
For each item in _items_, print its symbolic name, then its current value. This is useful for adding print statemetns into LISP code.

Example usage:
{{{
(deftest test-o ()
  (let* ((a 'tim)
         (b 'tom)
         (result  
			(with-output-to-string (s)
               (let ((*standard-output* s))
                  (o a b)))))
    (check
      (samep result
             "[A]=[TIM] [B]=[TOM]"))))
}}}
</dd>
</dl>
==== Macros for Iteration =====
<dl>
<dt>_(dohash (key value hash &optional out) body) _ </dt><dd>
For each _key_ and _value_ in _hash_, call _body_. Useful for traversing all items in a hash table.
Returns _out_ (defaults to nil).
</dd>
<dt>_(doitems (item integer list &optional out) body) _ </dt><dd>
For each _item_ at position _integer_ within the _list_,  call _body_. Useful for traversing all items in a list while knowing
your index in the list.
Returns _out_ (defaults to nil).

For example:

{{{
(deftest test-doitems ()
  (check (samep
          (with-output-to-string (s)
            (doitems (item pos '(the quick brown fox))
              (format s "~a is at position ~a~%" item pos)))

          "THE is at position 0
           QUICK is at position 1
           BROWN is at position 2
           FOX is at position 3"
)))
}}}
</dd>
</dl>

==== Macros for Profiling ====

<dl>
<dt>_(watch  code) _ </dt><dd>
Run _code_ and report what functions took the most time. Useful for optimization.
For example, the following _watch_ result shows that 12/28=43% of the runtimes of _test-normal_
is spend computing the mean value. Clearly, incrementally updating the mean would be a candidate optimization for this code.
{{{
CL-USER> (watch (test-normal))
      seconds  |   consed  | calls |  sec/call  |  name  
    -------------------------------------------------------
         0.016 |   613,888 |     9 |   0.001777 | ADD
         0.012 |   540,256 |     2 |   0.005999 | MEAN
         0.000 |         0 |   114 |   0.000000 | WHITESPACEP
         0.000 |    16,296 |     2 |   0.000000 | SAMEP
         0.000 |         0 |     1 |   0.000000 | NORMAL-SUM
         0.000 |         0 |     4 |   0.000000 | REPORT-RESULT
         0.000 |    24,536 |     1 |   0.000000 | PDF
         0.000 |         0 |     1 |   0.000000 | NORMAL-N
         0.000 |         0 |    13 |   0.000000 | SQUARE
         0.000 |         0 |     1 |   0.000000 | NORMAL-MIN
         0.000 |         0 |     1 |   0.000000 | MAKE-NORMAL
         0.000 |     8,192 |     4 |   0.000000 | WHITEOUT
         0.000 |    16,360 |     2 |   0.000000 | STDEV
         0.000 |         0 |     1 |   0.000000 | NORMAL-SUMSQ
         0.000 |     8,184 |     1 |   0.000000 | TEST-NORMAL
         0.000 |         0 |     1 |   0.000000 | NORMAL-MAX
    -------------------------------------------------------
         0.028 | 1,227,712 |   158 |            | Total
}}}
CL-USER> 
</dd>
</dl>
=== number.lisp ===
<dl>
<dt>_(square  number) _ </dt><dd>
Returns the square of a number. 
</dd>
</dl>
=== random.lisp ===
It is hard to reproduce the behavior of  code that uses random number generation. This is a problem when tracking down bugs or when
writing _deftest_s. Hence, sometimes it is useful to use random number generators that build random number _X<sub>i</sub>_ from 
random number _X<sub>i-1</sub>_. 
The behavior of code that uses these _pseudo-random generators_ can then be reproduced by setting the "seed"; i.e.
_X<sub>0</sub>_.
<dl>
<dt>_(my-random number)_</dt>
<dd>Returns a pseudo-random float in the range zero to _number_.</dd>
<dt>_(my-random-int number)_</dt>
<dd>Returns a pseudo-random integer in the range zero to _number_.</dd>
<dt>_(reset-seed)_</dt>
<dd>Resets the random number seed to an initial value.</dd>
</dl>
=== Abstract Data Types ===
==== caution.lisp ====
A _caution_ is a place to store a list of errors seen thus far. Such _caution_ structures have finite patience (initially set to 20)
and after enough errors, _caution_ calls a halt to the processing.
{{{
defstruct (caution (:print-function caution-print))
  all (patience 20) killed)

(defun caution-print (c s depth)
  (declare (ignore depth))
  (format s "#(CAUTION :ALL ~a :PATIENCE ~a)"
          (caution-all c)
          (caution-patience c)))
}}}
_Caution_ is useful when parsing user inputted data structures. If the user makes too many errors, _caution_ calls a halt.
<dl>
<dt>(ok test cautions format-str &rest args)
</dt>
<dd>If _test_ return nil, then a new string (generated using _(format nil format-str ,@args)_ is added to cautions.

For example, here's the Ourmine function called when it expects to see a number. If _datum_ is not a number then a new error
message is added to the _cautions_ structure: 
{{{
(defmethod datum ((column numeric) datum cautions)
  (ok (numberp datum) cautions "~a is not a number" datum)
  t)
}}}
</dd>
</dl>
==== normal.lisp ====
A _normal_ is a place to summarize a stream of numeric Gaussian data.  Each addition to a _normal_ updates the information  required to determine 
the mean, standard deviation, etc.
{{{
(defstruct normal 
  (max (* -1 most-positive-single-float))
  (min       most-positive-single-float)
  (n 0)
  (sum 0)
  (sumSq 0))
}}}
<dl>
<dt>_(add  normal number)_</dt> <dd>Add a _number_ to a _normal_ distribution</dd>
<dt>_(mean normal)_</dt> <dd>Returns the mean of a  _normal_ distribution</dd>
<dt>_(stdev normal)_</dt> <dd>Returns the standard deviation of a _normal_ distribution.</dd>
<dt>_(pdf normal number)_</dt> <dd>Returns the probability of _number_ belonging to a normal distributon.</dd>
</dl>
== table ==

== learn == 
