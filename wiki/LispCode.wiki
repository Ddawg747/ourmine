#summary Notes on Ourmine's LISP code.


<wiki:toc max_depth="4" />  

= The Big Picture =

== Development Structure ==

This code was written using a test-driven approach; i.e. whenever I built a new functionality, I wrote a _deftest_ command to test that code. 

{{{
(deftest test-normal ()
  (let ((n (make-normal)))
    (dolist (x '( 1 2 3 4 5 4 3 2 1))
      (add n x))
    (check 
      (samep n "#S(NORMAL :MAX 5 :MIN 1 :N 9 :SUM 25 :SUMSQ 85)")
      (equal (mean n) (/ 25 9))
      (equal (stdev n) 1.3944334)
      (samep (format nil "~10,9f" (pdf n 5))  ".080357649")
    )))
}}}
This code throws a set of numbers at a normal distribution. If it is working correctly, then that distribution should generate certain values.

The above shows four _check_s. The _samep_ functions checks if two forms evaluate to the same print string, ignoring minor details like white space and capitalization.

A site effect of using _deftest_ is that a global _*tests*_ stores all the known tests and the _(tests)_ function can report what percent of the test suite is working right now.

It is impossible to understate the value of this kind of development. Everyday, I stop with a broken test. Every new day, I start with the test broken from last night. And if ever I make any changes to anything, I can check if that breaks anything else.

== Code structure ==

At the time of this writing, the main LISP directory is our/lib/lisp. This is broken down into:

 * [#miner.lisp our/lib/lisp/miner.lisp] : main load file. Loads the rest of the code.
 * [#tests our/lib/lisp/tests] : code for test suite
 * [#tricks our/lib/lisp/tricks] : general LISP utils
 * [#table our/lib/lisp/table] : code for storing data 
 * [#learn our/lib/lisp/learn] : code for learners 

This code structure will be discussed below.

== Getting Started ==

First, you have to [http://ourmine.googlecode.com install Ourmine]. Then
at the UNIX shell prompt:
{{{
cd ~/opt/our/lib/lisp
emacs
}}}
Once inside EMACS:
{{{
M-x slime
(load "miner.lisp")
}}}

== Data Structure ==

=== Main Data Structures ===

At the time of this writing, the main data structures are:

 * *eg* : an example data row
 * *header* : meta-information about each column of data (e.g. the maximum and minimum number seen in an row in a particular column). Headers have two sub-classes
   * *Discrete* : for non-numeric data
   * *Numeric*  : for numeric data
 * *table* : combines examples with column headers. 
 

For example, this code returns a _table_ with five _eg_s, one for each row of the data:

{{{
(defun did-you-play-golf ()
  (data
    :name   'weather
    :columns '( forecast temp humidity $wind play)
    :egs     '((sunny    hot  high     20    no) 
               (sunny    hot  high     10    no) 
               (sunny    hot  high     30    no) 
               (sunny    hot  high     20.2  yes)
               (sunny    hot  high     20.1  yes)
               (sunny    hot  high     20.7  yes)
              )
)
}}}

The table has four _discrete_ columns (forecast, temp, humidity, play) and one numeric one (denoted with a "$" sign: see"$wind"). The last column is the _class_ (so it  columns satisfies _header-classp_).  

Optionally, the columns can store frequency counts of the data seen in each column.  The code

{{{
(xindex (did-you-play-golf))
}}}
runs over the table and:
 * For _discrete_ columns, it stores the count of symbols seen in each class.
 * _Numeric_ columns are summarized,  assuming  [http://en.wikipedia.org/wiki/Normal_distribution normal distributions].


=== Other Structures ==

 * *normal* : used to store normal distributions and report mean, standard deviation, pdf, etc.
 * *caution* : collects any error strings on flaws found  when reading the data. If two many flaws are found, _caution_ calls an abort.

= The Details = 

== miner.lisp ==

This file defines a list of files to load; e.g. 
{{{
(defparamater *files* '(
                          "tests/deftest"
                          "tricks/lispfuns"
                          etc
                       ))
}}}
Once this file is loaded, then the whole system can be reloaded with _make_. 
{{{
(defun make (&optional (verbose nil))
  (if verbose
      (make1 *files*)
      (handler-bind 
          ((style-warning #'muffle-warning))
        (make1 *files*))))
}}}
_make_ works in two modes. The call _(make)_ loads the system, suppressing SBCL's verbose load information. To see that output, use _(make t)_.

Note that there is a better way to define systems in LISP- the asdf system. But while debugging this code, I found some quirks in my local
installation of that system, so....

== tests ==

 <em>Debugging had to be discovered.  I can remember the exact instant when I realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs. </em>
<br>--Maurice Wilkes, 1949



At least half the development time of any system is spent debugging the code. So it is worthwhile to spend a little time
simplifying this very, very, common task.

The unit test system used by Ourmine is based on code  from Peter Seibel. The _deftest_ macro calls a _defun_ and, as a side-effect, registers
the test in a list *tests*. One test can can contain _check_s and, if passed, each _check_ adds one to a counter of passed tests:
{{{
(deftest test-normal ()
  (let ((n (make-normal)))
    (dolist (x '( 1 2 3 4 5 4 3 2 1))
      (add n x))
    (check 
      (samep n "#S(NORMAL :MAX 5 :MIN 1 :N 9 :SUM 25 :SUMSQ 85)")
      (equal (mean n) (/ 25 9))
      (equal (stdev n) 1.3944334)
      (samep (format nil "~10,9f" (pdf n 5))  ".080357649")
    )))
}}}
An individual test like _test-normal_ can be 
called like any other function.

All the current tests can be called using _(tests)_. 
When _(tests)_ terminates, it reports what percent of tests passed/failed.


== tricks ==

Tricks stores some common COMMON LISP tricks- should be useful for more than just Ourmine.

=== list.lisp ===
<dl>
<dt>_(shuffle list)_ </dt>
<dd>Returns a randomly reordered _list_. Note: the original _list_ is changed by this function.</dd>
</dl>
=== string.lisp ===
<dl>
<dt>_(lt x y)_ </dt><dd>
Returns true if _x_ is   less than _y_.
</dd>
<dt>_(nchars integer &optional char)_ </dt><dd>
Returns a string of length _integer_ containing _char_ (default: space).
</dd>
<dt>_(samep x y)_ </dt><dd>
Returns true if a  string comparison of the results _x_ and the results of _y_
are lexicographically different. Ignores differences like whitespace of upper or lower case.
</dd>
<dt>_(whiteout seq)_ </dt><dd>
Returns a sequence without any whitespace (space, tab, newline, page breaks).
</dd>
</dl>

=== hash.lisp ===
<dl>
<dt>_(print-object hash stream)_ </dt><dd>
Redefines the printed representation of a hashtable. 
</dd>
<dt>_(showh hash &key indent stream before after if-empty show lt)_ </dt><dd>
Pretty prints the contents of _hash_ on _stream_ (defaults to standard output). 
The strings _before_ and _after_ are printed before and after showing the hash table contents.
Buckets are printed in a sort order controlled by _lt_. If a bucket is empty, _if-empty_ is shown.

In this example, fruit is stored in a hash table at a key equal to the string length of the fruit (e.g. "PEAR" goes to "4"):
{{{
(deftest test-showh ()
  (let ((h (make-hash-table)))
    (dolist (one '(apple pear banana))
      (setf (gethash (length (string one)) h) one))
   (check
     (samep (with-output-to-string (s) 
            (showh h  :stream s))
                "4 = PEAR
                 5 = APPLE
                 6 = BANANA"
))))
}}}
</dd>
</dl>
=== macros.lisp ===
==== Macros for Debugging =====

<dl>
<dt>_(o &rest items)_</dt><dd>
For each item in _items_, print its symbolic name, then its current value. This is useful for adding print statements into LISP code.

Example usage:
{{{
(deftest test-o ()
  (let* ((a 'tim)
         (b 'tom)
         (result  
			(with-output-to-string (s)
               (let ((*standard-output* s))
                  (o a b)))))
    (check
      (samep result
             "[A]=[TIM] [B]=[TOM]"))))
}}}
</dd>
</dl>
==== Macros for Iteration =====
<dl>
<dt>_(dohash (key value hash &optional out) body) _ </dt><dd>
For each _key_ and _value_ in _hash_, call _body_. Useful for traversing all items in a hash table.
Returns _out_ (defaults to nil).
</dd>
<dt>_(doitems (item integer list &optional out) body) _ </dt><dd>
For each _item_ at position _integer_ within the _list_,  call _body_. Useful for traversing all items in a list while knowing
your index in the list.
Returns _out_ (defaults to nil).

For example:

{{{
(deftest test-doitems ()
  (check (samep
          (with-output-to-string (s)
            (doitems (item pos '(the quick brown fox))
              (format s "~a is at position ~a~%" item pos)))

          "THE is at position 0
           QUICK is at position 1
           BROWN is at position 2
           FOX is at position 3"
)))
}}}
</dd>
</dl>

==== Macros for Profiling ====

<dl>
<dt>_(watch  code) _ </dt><dd>
Run _code_ and report what functions took the most time. Useful for optimization.
For example, the following _watch_ result shows that 12/28=43% of the runtimes of _test-normal_
is spend computing the mean value. Clearly, incrementally updating the mean would be a candidate optimization for this code.
{{{
CL-USER> (watch (test-normal))
      seconds  |   consed  | calls |  sec/call  |  name  
    -------------------------------------------------------
         0.016 |   613,888 |     9 |   0.001777 | ADD
         0.012 |   540,256 |     2 |   0.005999 | MEAN
         0.000 |         0 |   114 |   0.000000 | WHITESPACEP
         0.000 |    16,296 |     2 |   0.000000 | SAMEP
         0.000 |         0 |     1 |   0.000000 | NORMAL-SUM
         0.000 |         0 |     4 |   0.000000 | REPORT-RESULT
         0.000 |    24,536 |     1 |   0.000000 | PDF
         0.000 |         0 |     1 |   0.000000 | NORMAL-N
         0.000 |         0 |    13 |   0.000000 | SQUARE
         0.000 |         0 |     1 |   0.000000 | NORMAL-MIN
         0.000 |         0 |     1 |   0.000000 | MAKE-NORMAL
         0.000 |     8,192 |     4 |   0.000000 | WHITEOUT
         0.000 |    16,360 |     2 |   0.000000 | STDEV
         0.000 |         0 |     1 |   0.000000 | NORMAL-SUMSQ
         0.000 |     8,184 |     1 |   0.000000 | TEST-NORMAL
         0.000 |         0 |     1 |   0.000000 | NORMAL-MAX
    -------------------------------------------------------
         0.028 | 1,227,712 |   158 |            | Total
}}}
</dd>
</dl>
=== number.lisp ===
<dl>
<dt>_(square  number) _ </dt><dd>
Returns the square of a number. 
</dd>
</dl>
=== random.lisp ===

It is hard to reproduce the behavior of  code that uses random number generation. This is a problem when tracking down bugs or when
writing tests. Hence, sometimes it is useful to use random number generators that build random number _X<sub>i</sub>_ from 
random number _X<sub>i-1</sub>_. 
The behavior of code that uses these _pseudo-random generators_ can then be reproduced by setting the "seed"; i.e.
_X<sub>0</sub>_.

<dl>
<dt>_(my-random number)_</dt>
<dd>Returns a pseudo-random float in the range zero to _number_.</dd>
<dt>_(my-random-int number)_</dt>
<dd>Returns a pseudo-random integer in the range zero to _number_.</dd>
<dt>_(reset-seed)_</dt>
<dd>Resets the random number seed to an initial value.</dd>
</dl>
=== Abstract Data Types ===
==== caution.lisp ====
A _caution_ is a place to store a list of errors seen thus far. Such _caution_ structures have finite patience (initially set to 20)
and after enough errors, _caution_ calls a halt to the processing.
{{{
(defstruct (caution (:print-function caution-print))
  all (patience 20) killed)

(defun caution-print (c s depth)
  (declare (ignore depth))
  (format s "#(CAUTION :ALL ~a :PATIENCE ~a)"
          (caution-all c)
          (caution-patience c)))
}}}
_Caution_ is useful when parsing user inputted data structures. If the user makes too many errors, _caution_ calls a halt.
<dl>
<dt>(ok test cautions format-str &rest args)
</dt>
<dd>If _test_ return nil, then a new string (generated using _(format nil format-str ,@args)_ is added to cautions.

For example, here's the Ourmine function called when it expects to see a number. If _datum_ is not a number then a new error
message is added to the _cautions_ structure: 
{{{
(defmethod datum ((column numeric) datum cautions)
  (ok (numberp datum) cautions "~a is not a number" datum)
  t)
}}}
</dd>
</dl>
==== normal.lisp ====
A _normal_ is a place to summarize a stream of numeric Gaussian data.  Each addition to a _normal_ updates the information  required to determine 
the mean, standard deviation, etc.
{{{
(defstruct normal 
  (max (* -1 most-positive-single-float))
  (min       most-positive-single-float)
  (n 0)
  (sum 0)
  (sumSq 0))
}}}
<dl>
<dt>_(add  normal number)_</dt> <dd>Add a _number_ to a _normal_ distribution</dd>
<dt>_(mean normal)_</dt> <dd>Returns the mean of a  _normal_ distribution</dd>
<dt>_(stdev normal)_</dt> <dd>Returns the standard deviation of a _normal_ distribution.</dd>
<dt>_(pdf normal number)_</dt> <dd>Returns the probability of _number_ belonging to a normal distribution.</dd>
</dl>
== table ==

When we read data, we have to store it somewhere. Ourmine uses _table_:
{{{
(defstruct table 
  name                      ; symbol          : name of the table
  columns                   ; list of header  : one header to describe each column of data
  class                     ; number          : which column is the header column?
  (cautions (make-caution)) ; list of caution : any load-time errors?
  all                       ; list of eg      : all the examples
  indexed
)
}}}

The _data_ function  builds _table_s. The list of words given to _:columns: defines each column of the data. For example,
in the following, _windy_ is marked with a "$" so we expect all numbers in that column.
{{{
(defun make-data1 ()
  (data
   :name   'weather
   :columns '(forecast temp humidity $windy play)
   :egs    '((sunny    hot  high   FALSE no) 
             (sunny    hot  high   TRUE  yes)
             (sunny    hot  high         yes)
             )))
}}}
Note that the data has some errors. Row 3 does not have enough columns and all the values in the _windy_ column are non-numeric.
The following call shows that Ourmine has seen those errors:
{{{
CL-USER> (make-data1)

 #S(TABLE
   :NAME WEATHER
   :COLUMNS (#S(DISCRETE
                :NAME FORECAST
                :CLASSP NIL
                :IGNOREP NIL
                :F {hash of 0 items}
                :UNIQUES (SUNNY))
             #S(DISCRETE
                :NAME TEMP
                :CLASSP NIL
                :IGNOREP NIL
                :F {hash of 0 items}
                :UNIQUES (HOT))
             #S(DISCRETE
                :NAME HUMIDITY
                :CLASSP NIL
                :IGNOREP NIL
                :F {hash of 0 items}
                :UNIQUES (HIGH))
             #S(NUMERIC
                :NAME $WINDY
                :CLASSP NIL
                :IGNOREP NIL
                :F {hash of 0 items})
             #S(DISCRETE
                :NAME PLAY
                :CLASSP T
                :IGNOREP NIL
                :F {hash of 0 items}
                :UNIQUES (YES NO)))
   :CLASS 4
   :CAUTIONS #(CAUTION :ALL ((SUNNY HOT HIGH YES) wrong size
                             TRUE is not a number
                             FALSE is not a number) :PATIENCE 17)
   :ALL (#S(EG :FEATURES (SUNNY HOT HIGH TRUE YES) :CLASS YES)
         #S(EG :FEATURES (SUNNY HOT HIGH FALSE NO) :CLASS NO))
   :INDEXED NIL)
}}}
The above code shows
a <em>table</em> (on the outside) containing five _header_s (four _discrete_ and one _numeric_) describing each column
of data. 
For the _discrete_ headers, the  set of unique symbols seen in each column is stored in the _:uniques_ slot.
The _:class_ slot shows that the class variable is the fifth header (which, you will note, has _:classp T_).   
An _all_ slot stores all the examples.
Each example as some _:features_ and a  _:class_ value.
 
The _:indexed_ slot of the above is NIL. A _table_ becomes indexed when the _xindex_ function does some detailed counts of the symbols
seen in all the rows. We will return to this function is just a moment.
Note that the  file _our/lib/lisp/data.lisp_ defines a hook that triggers whenever we see discrete or number data. This hook has two methods (one for each column type). For example, this hook notes when we have missed a numeric column.
{{{
(defmethod datum ((column discrete) datum oops)
  "things to do when reading a discrete datum"
  (declare (ignore  oops))
  (unless (member datum (discrete-uniques column))
    (push datum (discrete-uniques column)))
  t)

(defmethod datum ((column numeric) datum oops)
  "things to do when reading a numeric datum"
  (ok (numberp datum) oops"~a is not a number" datum)
  t)
}}}

Returning now to _xindex_, this function stores the information about the distribution in the _f_ slot of _header_ structures.
{{{
; e.g.
(xindex (make-data1))
}}}
Just as with _datum_, there is a hook defined for handling numeric data differently to numeric data (see _our/lib/lisp/xindex.lisp_):
{{{
(defmethod xindex-datum ((column discrete) class  datum)
  (let* ((key `(,class ,datum))
         (hash (header-f column)))
    (incf (gethash key hash 0))))

(defmethod xindex-datum ((column numeric) class  datum)
  (let* ((key      class)
         (hash     (header-f column))
         (counter  (gethash  key hash (make-normal))))
    (setf (gethash key hash) counter) ; make sure the hash has the counter
    (add counter datum)))
}}}
(The _add_ method comes from the _normal_ code, described above.)

Note that distribution information is hashed on class name; i.e. separate distribution information is kept for each class.
For example, the following data has very different mean values  for _$humidity_. Also, _forecast=overcast_ appears four times
in class=YES but never in class=NO.
{{{
(defun make-some-weather-data ()
  (data
   :name   'weather
   :columns '(forecast $temp $humidity wind play)
   :egs    '((sunny 85 85 FALSE no)
             (sunny 80 90 TRUE no)
             (overcast 83 86 FALSE yes)
             (rainy 70 96 FALSE yes)
             (rainy 68 80 FALSE yes)
             (rainy 65 70 TRUE no)
             (overcast 64 65 TRUE yes)
             (sunny 72 95 FALSE no)
             (sunny 69 70 FALSE yes)
             (rainy 75 80 FALSE yes)
             (sunny 75 70 TRUE yes)
             (overcast 72 90 TRUE yes)
             (overcast 81 75 FALSE yes)
             (rainy 71 91 TRUE no))))

(deftest test-some-counts ()
  (check
    (samep 
     (with-output-to-string (str)
       (dolist (col (table-columns (xindex (make-some-weather-data))))
         (format str "~%~a~%" (header-name col))
         (showh (header-f col) :indent 10 :stream str)))
    "
    FORECAST
          (NO RAINY) = 2
          (NO SUNNY) = 3
          (YES OVERCAST) = 4
          (YES RAINY) = 3
          (YES SUNNY) = 2

    $TEMP
          NO = #S(NORMAL :MAX 85 :MIN 65 :N 5 :SUM 373 :SUMSQ 28075)
          YES = #S(NORMAL :MAX 83 :MIN 64 :N 9 :SUM 657 :SUMSQ 48265)

    $HUMIDITY
          NO = #S(NORMAL :MAX 95 :MIN 70 :N 5 :SUM 431 :SUMSQ 37531)
          YES = #S(NORMAL :MAX 96 :MIN 65 :N 9 :SUM 712 :SUMSQ 57162)

    WIND
          (NO FALSE) = 2
          (NO TRUE) = 3
          (YES FALSE) = 6
          (YES TRUE) = 3

    PLAY
          (NO NO) = 5
          (YES YES) = 9")))

}}}
For convenience, the _f_ function allows simple access to the frequency counts. It can be called with 1,2,of 4 arguments depending on
how much information you want.
<dl>
<dt>_(f tbl)_ </dt>
<dd>Return the number of examples in a table </dd>
<dt>_(f tbl class)_ </dt>
<dd>Return the number of examples of one _class_ in a table </dd>
<dt>_(f tbl class index range)_ </dt>
<dd>Return the number of examples in one _class_ of  a table in _index_-th column with a certain _range_. </dd>
</dl>
== learn == 
With all the above machinery, we can now define a learner. A _Naive Bayes_ classifier takes a training and a test data set.
_Xindex_ is called on the training set, and the resulting statistics are applied on the test set.

Ignoring for the moment the details of its internal working, here's how we'd call it:
{{{
(defun nb-simple (train test &key (stream t))
  (xindex train)
  (dolist (one (table-all test))
    (let* ((got     (bayes-classify (eg-features one) train))
           (want    (eg-class one))
           (success (eql got want)))
      (format stream "~a ~a ~a~%"  got want 
              (if (eql got want) "   " "<--")))))

 (defun make-weather (eg)
    (data :name    'weather 
          :columns '(forecast temp humidity windy play)  
          :egs     '((sunny    hot  high   TRUE  skip)
                	 (rainy    cool normal TRUE  skip)    
                	 (sunny    mild high   FALSE skip)
                	 (overcast cool normal TRUE  play)
                	 (overcast hot  high   FALSE play)
                	 (rainy    mild high   FALSE play)
                	 (rainy    cool normal FALSE play)
                	 (sunny    cool normal FALSE play)
                	 (rainy    mild normal FALSE play)
                	 (rainy    mild high   TRUE  skip)
                	 (sunny    mild normal TRUE  play)
                	 (overcast mild high   TRUE  play)
                	 (overcast hot  normal FALSE play))))
}}}
This produces:
{{{
CL-USER> (nb-simple  (make-weather egs) (make-weather egs))
PLAY PLAY    
PLAY PLAY    
PLAY PLAY    
SKIP SKIP    
PLAY PLAY    
PLAY PLAY    
PLAY PLAY    
PLAY PLAY    
PLAY PLAY    
PLAY PLAY    
PLAY SKIP <--
PLAY SKIP <--
SKIP SKIP    
SKIP SKIP    
}}}
Note that our learner nearly works in every case (see the arrowed lines).

But how does the learner work? Well, that requires a little data mining theory. To conclude this
walk through, all we need to 
say at this time is that the classifier returns what it thinks is the mostly likely classification of one example.
{{{
(defun bayes-classify (one tbl &optional (m 2) (k 1))
  (let* ((classes        (klasses tbl))        ; all the class names
         (nclasses       (nklasses tbl))       ; number of classes 
         (n              (f        tbl))       ; number of instances
         (classi         (table-class tbl))    ; what column has the class
         (like           most-negative-fixnum)
         (classification (first classes)))     ; default classification
    (dolist (class classes)                      ; for all classes do...
      (let* ((prior (/ (+ (f tbl class) k)       ; again, we call "f".
                       (+  n (* k nclasses))))
             (tmp   (log prior)))
        (doitems (feature i one)
          (unless (= classi i)
            (unless (unknownp feature)
              (let ((delta (/ (+ (f tbl class i feature) ; note the call to "f"
                                 (* m prior))
                              (+ (f tbl class) m))))     ; note the call to "f"
                (incf tmp (log delta))))))
        (when (> tmp like)                      ; if you've got something better
          (setf like tmp
                classification class))))        ; switch to it
    classification))                          ; return the classification
}}}
