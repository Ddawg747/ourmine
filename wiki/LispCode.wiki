#summary Notes on Ourmine's LISP code.


<wiki:toc max_depth="4" />  

= The Big Picture =

== Development Structure ==

This code was written using a test-driven approach; i.e. whenever I built a new functionality, I wrote a _deftest_ command to test that code. 

{{{
(deftest test-normal ()
  (let ((n (make-normal)))
    (dolist (x '( 1 2 3 4 5 4 3 2 1))
      (add n x))
    (check 
      (samep n "#S(NORMAL :MAX 5 :MIN 1 :N 9 :SUM 25 :SUMSQ 85)")
      (equal (mean n) (/ 25 9))
      (equal (stdev n) 1.3944334)
      (samep (format nil "~10,9f" (pdf n 5))  ".080357649")
    )))
}}}
This code throws a set of numbers at a normal distribution. If it is working correctly, then that distribution should generate certain values.

The above shows four _check_s. The _samep_ functions checks if two forms evaluate to the same print string, ignoring minor details like white space and capitalization.

A site effect of using _deftest_ is that a global _*tests*_ stores all the known tests and the _(tests)_ function can report what percent of the test suite is working right now.

It is impossible to understate the value of this kind of development. Everyday, I stop with a broken test. Every new day, I start with the test broken from last night. And if ever I make any changes to anything, I can check if that breaks anything else.

== Code structure ==

At the time of this writing, the main LISP directory is our/lib/lisp. This is broken down into:

 * [#miner.lisp our/lib/lisp/miner.lisp] : main load file. Loads the rest of the code.
 * [#tests our/lib/lisp/tests] : code for test suite
 * [#tricks our/lib/lisp/tricks] : general LISP utils
 * [#table our/lib/lisp/table] : code for storing data 
 * [#learn our/lib/lisp/learn] : code for learners 

This code structure will be discussed below.

== Getting Started ==

First, you have to [http://ourmine.googlecode.com install Ourmine]. Then
at the UNIX shell prompt:
{{{
cd ~/opt/our/lib/lisp
emacs
}}}
Once inside EMACS:
{{{
M-x slime
(load "miner.lisp")
}}}

== Data Structure ==

=== Main Data Structures ===

At the time of this writing, the main data structures are:

 * *eg* : an example data row
 * *header* : meta-information about each column of data (e.g. the maximum and minimum number seen in an row in a particular column). Headers have two sub-classes
   * *Discrete* : for non-numeric data
   * *Numeric*  : for numeric data
 * *table* : combines examples with column headers. 
 

For example, this code returns a _table_ with five _eg_s, one for each row of the data:

{{{
(defun did-you-play-golf ()
  (data
    :name   'weather
    :columns '( forecast temp humidity $wind play)
    :egs     '((sunny    hot  high     20    no) 
               (sunny    hot  high     10    no) 
               (sunny    hot  high     30    no) 
               (sunny    hot  high     20.2  yes)
               (sunny    hot  high     20.1  yes)
               (sunny    hot  high     20.7  yes)
              )
)
}}}

The table has four _discrete_ columns (forecast, temp, humidity, play) and one numeric one (denoted with a "$" sign: see"$wind"). The last column is the _class_ (so it  columns satisfies _header-classp_).  

Optionally, the columns can store frequency counts of the data seen in each column.  The code

{{{
(xindex (did-you-play-golf))
}}}
runs over the table and:
 * For _discrete_ columns, it stores the count of symbols seen in each class.
 * _Numeric_ columns are summarized,  assuming  [http://en.wikipedia.org/wiki/Normal_distribution normal distributions].


=== Other Structures ==

 * *normal* : used to store normal distributions and report mean, standard deviation, pdf, etc.
 * *caution* : collects any error strings on flaws found  when reading the data. If two many flaws are found, _caution_ calls an abort.

= The Details = 

== miner.lisp ==

This file defines a list of files to load; e.g. 
{{{
(defparamater *files* '(
                          "tests/deftest"
                          "tricks/lispfuns"
                          etc
                       ))
}}}
Once this file is loaded, then the whole system can be reloaded with _make_. 
{{{
(defun make (&optional (verbose nil))
  (if verbose
      (make1 *files*)
      (handler-bind 
          ((style-warning #'muffle-warning))
        (make1 *files*))))
}}}
_make_ works in two modes. The call _(make)_ loads the system, suppressing SBCL's verbose load information. To see that output, use _(make t)_.

Note that there is a better way to define systems in LISP- the asdf system. But while debugging this code, I found some quirks in my local
installation of that system, so....

== tests ==

 <em>Debugging had to be discovered.  I can remember the exact instant
when I realized that a large part of my life from then on was going
to be spent in finding mistakes in my own programs. </em>
<br>--Maurice Wilkes, 1949



At least half the development time of any system is spent debugging the code. So it is worthwhile to spend a little time
simplifying this very, very, common task.

The unit test system used by Ourmine is based on code  from Peter Seibel. The _deftest_ macro calls a _defun_ and, as a side-effect, registers
the test in a list *tests*. One test can can contain _check_s and, if passed, each _check_ adds one to a counter of passed tests:
{{{
(deftest test-normal ()
  (let ((n (make-normal)))
    (dolist (x '( 1 2 3 4 5 4 3 2 1))
      (add n x))
    (check 
      (samep n "#S(NORMAL :MAX 5 :MIN 1 :N 9 :SUM 25 :SUMSQ 85)")
      (equal (mean n) (/ 25 9))
      (equal (stdev n) 1.3944334)
      (samep (format nil "~10,9f" (pdf n 5))  ".080357649")
    )))
}}}
An individual test like _test-normal_ can be 
called like any other function.

All the current tests can be called using _(tests)_. 
When _(tests)_ terminates, it reports what percent of tests passed/failed.


== tricks ==

Tricks stores some common COMMON LISP tricks- should be useful for more than just Ourmine.

=== list.lisp ===
<dl>
<dt>_(shuffle list)_ </dt>
<dd>Returns a randomly reordered _list_. Note: the original _list_ is changed by this function.</dd>
</dl>
=== string.lisp ===
<dl>
<dt>_(lt x y)_ </dt><dd>
Returns true if _x_ is lexogragphically less than _y_.
</dd>
<dt>_(nchars integer &optional char)_ </dt><dd>
Returns a string of length _integer_ containin _char_ (default: space).
</dd>
<dt>_(samep x y)_ </dt><dd>
Returns true if a  string comparison of the results _x_ and ithe results of _y_
are lexiographically different. Ignores differences like whitespace of upper or lower case.
</dd>
<dt>_(whiteout seq)_ </dt><dd>
Returns a sequence without any whitespace (space, tab, newline, page breaks).
</dd>
</dl>

=== hash.lisp ===
<dl>
<dt>_(print-object hash stream)_ </dt><dd>
Redefines the printed representation of a hashtable. 
</dd>
<dt>_(showh hash &key indent stream before after if-empty show lt)_ </dt><dd>
Pretty prints the contents of _hash_ on _stream_ (defaults to standard ouput). 
The strings _before_ and _after_ are printed before and after showing the hash table contents.
Buckets are printed in a sort order controlled by _lt_. If a bucket is empty, _if-empty_ is shown.

In this example, fruit is stored in a hash table at a key equal to the string length of the fruit (e.g. "PEAR" goes to "4"):
{{{
(deftest test-showh ()
  (let ((h (make-hash-table)))
    (dolist (one '(apple pear banana))
      (setf (gethash (length (string one)) h) one))
   (check
     (samep (with-output-to-string (s) 
            (showh h  :stream s))
                "4 = PEAR
                 5 = APPLE
                 6 = BANANA"
))))
}}}
</dd>
</dl>
=== macros.lisp ===
==== Macros for Debugging =====

<dl>
<dt>_(o &rest items)_</dt><dd>
For each item in _items_, print its symbolic name, then its current value. This is useful for adding print statemetns into LISP code.

Example usage:
{{{
(deftest test-o ()
  (let* ((a 'tim)
         (b 'tom)
         (result  (with-output-to-string (s)
                    (let ((*standard-output* s))
                      (o a b)))))
    (check
      (samep result
             "[A]=[TIM] [B]=[TOM]"))))
}}}
</dd>
</dl>
==== Macros for Iteration =====
<dl>
<dt>_(dohash (key value hash &optional out) body) _ </dt><dd>
For each _key_ and _value_ in _hash_, call _body_. Useful for traversing all items in a hash table.
Returns _out_ (defaults to nil).
</dd>
<dt>_(doitems (item integer list &optional out) body) _ </dt><dd>
For each _item_ at position _integer_ within the _list_,  call _body_. Useful for traversing all items in a list while knowing
your index in the list.
Returns _out_ (defaults to nil).

For example:

{{{
(deftest test-doitems ()
  (check (samep
          (with-output-to-string (s)
            (doitems (item pos '(the quick brown fox))
              (format s "~a is at position ~a~%" item pos)))

          "THE is at position 0
           QUICK is at position 1
           BROWN is at position 2
           FOX is at position 3"
)))
}}}
</dd>

=== number.lisp ===
=== random.lisp ===

=== Abstract Data Types ===
==== caution.lisp ====
==== normal.lisp ====

== table ==

== learn == 
