(defun prism-rules (table)
  (let* ((rules))
    (dolist (cls (klasses table) rules)
      (setf rules (append (list (get-rules table cls)) rules)))))

(defun get-top-rule (table class)
  (let* ((intel '())
         (class-col (table-class table))
         (skip (list class-col))
         (p 0)
         (rulefound 0)
         (tablelist (table-egs-to-lists table))
         (temptable tablelist)
         (cols (length (car temptable)))
         (currmaxpt)
         (maxpt)
         (count 0)
         (rule '()))
    (loop do
         (incf count)
      (dotimes (n (- cols 1))
        (if (null (position n skip))
            (progn
              (dolist (instance temptable)
                (setf p 0)
                (if (eql (nth class-col instance) class)
                    (setf p 1))
                (setf intel (add-intel intel n (nth n instance) p)))
              (setf maxpt (getmaxpt intel skip))
              (setf intel '())
              (if (null currmaxpt)
                  (setf currmaxpt maxpt)
                  (if (or (not (null (rassoc (second currmaxpt) rule)))(> (pt maxpt) (pt currmaxpt)))
                      (setf currmaxpt maxpt))))))
         (if (= (pt currmaxpt) 1)
             (progn
               (setf rulefound 1)
               (setf rule (acons (first currmaxpt) (second currmaxpt) rule))
               (return-from get-top-rule (cons class (list rule))))
             (progn
               (setf rule (acons (first currmaxpt) (second currmaxpt) rule))
               (setf temptable (remove-disobedient temptable (first currmaxpt) (second currmaxpt)))
               (setf skip (cons (first currmaxpt) skip))))
       until (or (= (length temptable) 0) (= rulefound 1)(= count 10)))
    rule))


(defun add-intel (intel n val p)
  (let* ((count -1))
    (if (= (length intel) 0)
        (setf intel (append (list (list n val p 1)) intel))
        (progn
          (dolist (item intel)
            (incf count)
            (if (eq (second item) val)
                (progn
                  (if (= p 1)
                      (incf (nth 2 (nth count intel))))
                  (incf (nth 3 (nth count intel)))
                  (return-from add-intel intel))))
          (setf intel (append (list (list n val p 1)) intel))))
    intel))
  
(defun pt (node)
  (/ (third node) (fourth node)))

(defun getmaxpt (intel skip)
  (let* ((currmax (car intel)))
    (dolist (item (cdr intel))
      (if (> (pt item) (pt currmax))
          (setf currmax item)))
    currmax))

(defun remove-disobedient (table col val)
  (remove-if #'(lambda(x) (not (eql (nth col x) val))) table))

(defun remove-got (table got)
  (remove-if #'(lambda(x)
                 (let* ((marked t))
                   (dolist (val got marked)
                     (if (not (eq (nth (car val) x) (cdr val)))
                         (return nil)))))
             table))

(defun get-rules (train class)
  (let* ((data (table-egs-to-lists train))
         (rule)
         (class-col (table-class train))
         (allrules '()))
    (loop do
         (setf rule (get-top-rule (make-simple-table (table-name train) (table-columns train) data) class))
         (setf allrules (append (cdr rule) allrules))
         (setf data (remove-got data (car (cdr rule))))
         until (no-more-class data class-col class))
    (cons class (reverse allrules))))

(defun no-more-class (data class-col class)
  (dolist (instance data t)
    (if (eq (nth class-col instance) class)
        (return-from no-more-class nil))))
