(defun numeric-preprocessor (tbl)
  (let ((classi (table-class tbl)))
    (dolist (eg (egs tbl))
      (doitems (feature i (eg-features eg))
        (let ((column-name (header-name (nth i (table-columns tbl)))))
          (unless (= classi i)
              (unless (unknownp feature)
                (if (numericp column-name)
                  (setf (nth i (eg-features eg)) (log (max 0.0001 feature)))))))))
    tbl))

(defun sub-sample (tbl)
  (multiple-value-bind (mclass mcount) (find-minority-class tbl)
    (dolist (klass (remove mclass (klasses tbl)))
      (do ((rows-removed 0)
           (classi (table-class tbl)))
          ((>= rows-removed (- (gethash (list klass klass) (header-f (table-class-header tbl))) mcount)))
          (let ((randomi (random (length (table-all tbl)))))
            (cond ((equalp klass (nth classi (eg-features (nth randomi (table-all tbl)))))
                    (setf (table-all tbl) (delete (nth randomi (table-all tbl)) (table-all tbl)))
                    (incf rows-removed))))))
    tbl))

(defun find-minority-class (tbl)
  (xindex tbl)
  (let ((minority-class nil)
        (minority-class-count most-positive-fixnum))
    (maphash #'(lambda (k v)
                (cond ((< v minority-class-count)
                      (setf minority-class k)
                      (setf minority-class-count v))))
             (header-f (table-class-header tbl)))
    (values (car minority-class) minority-class-count)))

(defun learn (train test &key (k 1)
                   (prep #'identity) ;Takes 1 table returns 1 table
                   (discretizer #'identity) ;Takes 1 table returns 1 table
                   (clusterer #'default-clusterer) ;Takes k and 1 table returns a list of tables
                   (fss #'identity) ;Takes 1 table returns 1 table
                   (classifier-train #'identity) ;Takes 1 table returns 1 table with training metadata
				   (classifier #'identity)) ;Takes 1 test instance and table with training metadata and returns prediction
  (let ((clusters nil)
		(results nil))
    (setf train (funcall prep train))
    (setf test (funcall prep test))
    (setf train (funcall discretizer train))
    (setf clusters (funcall clusterer k train))
	(dolist (cluster clusters)
		(setf cluster (funcall fss cluster))
		(setf cluster (funcall classifier-train cluster)))
	(dolist (instance (table-all test))
		(push (funcall classifier (eg-features instance) (get-cluster instance clusters)) results))
	(setf results (nreverse results))
	(multiple-value-bind (ah bh ch dh) (p-metrics test results)
		(dolist (klass (klasses train))
			(let* ((a (if (gethash klass ah) (gethash klass ah) 0))
				   (b (if (gethash klass bh) (gethash klass bh) 0))
				   (c (if (gethash klass ch) (gethash klass ch) 0))
				   (d (if (gethash klass dh) (gethash klass dh) 0))
				  (accuracy (/ (+ a d) (+ a b c d)))
				  (precision (/ d (+ c d)))
				  (pd (/ d (+ b d)))
				  (pf (/ c (+ a c)))
				  (f (/ (* 2 precision pd) (+ precision pd)))
				  (g (/ (* 2 pf pd) (+ pf pd))))
				(format t "~a, ~a, ~a, ~a, ~a, ~a, ~a, ~a, ~a, ~a~%" a b c d accuracy precision pd pf f g))))))

(defun default-clusterer (k train)
	k
	(list train))

(defun get-cluster (instance clusters)
	instance
	(car clusters))

(defun nb-train (train)
	(xindex train))

(defun nb-classify (instance train)
	(bayes-classify instance train))

(defun p-metrics (test results)
	(let* ((a (make-hash-table))
		   (b (make-hash-table))
		   (c (make-hash-table))
		   (d (make-hash-table))
		   (d-sum 0))
		(mapcar #'(lambda (want got) 
					(cond ((equalp want got)
							(inch want d))
						 (t (inch got c)
							(inch want b))))
				(mapcar #'eg-class (table-all test)) results)
		(maphash #'(lambda (k v) k (setf d-sum (+ d-sum v))) d)
		(maphash #'(lambda (k v) k (setf (gethash k a) (- d-sum v))) d)
		(values a b c d)))
